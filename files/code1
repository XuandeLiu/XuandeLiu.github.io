import numpy as np
import pandas as pd
from hkvol.models.base import PerSymbolModel  # assuming base class is defined elsewhere

class LinearIntradayVolumeModel(PerSymbolModel):
    """
    Linear multi-equation intraday volume model based on 
    'A simple linear alternative to MEM for trading volume' (Clements et al. 2021).
    """
    def __init__(self):
        # Initialize storage for per-interval models
        self.num_intervals = None
        self.coefs = {}       # dict: interval -> coefficient array (including intercept)
        self.resid_std = {}   # dict: interval -> residual standard deviation
        # Store last training day's volumes for prediction start
        self.last_train_vols = None  

    def fit(self, data: pd.DataFrame):
        """
        Train a separate OLS regression for each intraday interval using the provided DataFrame.
        `data` is expected to contain one symbol's intraday volume history (e.g., 3 years).
        It must include identifiable day and interval information (either via index or columns).
        """
        # Ensure DataFrame has 'date' and 'interval' columns for grouping (extract if index has them)
        df = data.copy()
        if isinstance(df.index, pd.MultiIndex):
            # If MultiIndex, assume levels are (date, interval)
            df = df.reset_index()
        if 'datetime' in df.columns:
            # If a full datetime is available, extract date and possibly a numeric interval index
            df['date'] = df['datetime'].dt.date
            # If no explicit interval index, create one grouped by date (1...N for each day)
            if 'interval' not in df.columns:
                # sort by time within each date to assign interval order
                df = df.sort_values(['date', 'datetime'])
                df['interval'] = df.groupby('date').cumcount() + 1
        # Now we should have 'date', 'interval', and 'amount' (volume) columns
        if 'date' not in df.columns or 'interval' not in df.columns:
            raise ValueError("Input DataFrame must contain 'date' and 'interval' columns identifying each bar.")
        if 'amount' not in df.columns:
            # If volume column has a different name, try to infer (e.g., 'volume')
            vol_col_candidates = [col for col in ['volume', 'vol', 'amount'] if col in df.columns]
            if vol_col_candidates:
                df['amount'] = df[vol_col_candidates[0]]
            else:
                raise ValueError("Input DataFrame must contain an 'amount' (trading volume) column.")

        # Determine number of intervals from the data (max interval index within a day)
        self.num_intervals = int(df['interval'].max())
        # Pivot the training data to shape: index = date, columns = interval, values = amount
        daily_vol = df.pivot(index='date', columns='interval', values='amount')
        # Ensure rows are sorted by date
        daily_vol = daily_vol.sort_index()
        # Save the last training dayâ€™s volumes for prediction initialization
        self.last_train_vols = daily_vol.iloc[-1].copy()

        # Fit OLS regression for each interval
        for i in range(1, self.num_intervals + 1):
            # Prepare design matrix X and target y for interval i
            if i == 1:
                # Interval 1 uses only previous day's same interval as predictor
                # We will use y_t = c1 + phi1 * y_{t-1,1} + error
                y = daily_vol[i].iloc[1:]            # from second day onwards
                prev_day_vol = daily_vol[i].iloc[:-1]  # previous day's same interval (align indices)
                X = np.column_stack([np.ones(len(y)), prev_day_vol.values])
            else:
                # Interval i uses previous interval (i-1) same day and previous day's i
                y = daily_vol[i].iloc[1:]            # skip first day (no prev day data)
                prev_interval_vol = daily_vol[i-1].iloc[1:]  # same days as y (since y starts day2)
                prev_day_vol = daily_vol[i].iloc[:-1]        # previous day values for interval i
                prev_day_vol = prev_day_vol.iloc[1:]         # align with y (skip first day for prev_day too)
                # Now y, prev_interval_vol, prev_day_vol all correspond from day2 to end
                X = np.column_stack([
                    np.ones(len(y)),
                    prev_interval_vol.values,
                    prev_day_vol.values
                ])
            # Solve OLS: beta = (X'X)^-1 X'y
            # (We can use numpy.linalg.lstsq for stability)
            beta, _, _, _ = np.linalg.lstsq(X, y.values, rcond=None)
            self.coefs[i] = beta  # store coefficients (including intercept as beta[0])
            # Compute residuals and their std dev
            y_pred = X.dot(beta)
            residuals = y.values - y_pred
            # Unbiased std (divide by N-p):
            dof = len(y) - X.shape[1]
            if dof > 0:
                sigma = np.sqrt((residuals**2).sum() / dof)
            else:
                sigma = np.sqrt((residuals**2).mean())  # fallback to RMSE if dof not positive
            self.resid_std[i] = sigma

    def predict(self, data: pd.DataFrame) -> pd.Series:
        """
        Generate volume predictions for each 5-minute interval in the provided DataFrame.
        The DataFrame should contain the timestamps (or date/interval identifiers) for the prediction horizon (e.g., 1 year test set).
        Returns a pandas Series of predicted volumes aligned to the input intervals.
        """
        if self.num_intervals is None or self.coefs is None:
            raise RuntimeError("Model is not fitted yet. Call fit() before predict().")

        # Prepare the input DataFrame similarly to fit()
        df = data.copy()
        if isinstance(df.index, pd.MultiIndex):
            df = df.reset_index()
        if 'datetime' in df.columns and 'date' not in df.columns:
            df['date'] = df['datetime'].dt.date
        if 'interval' not in df.columns:
            # If no interval given, assume data is sorted by time and assign sequential interval numbers per day
            df = df.sort_values(['date', 'datetime'] if 'datetime' in df.columns else ['date'])
            df['interval'] = df.groupby('date').cumcount() + 1

        # Create a pivot table of actual volumes for the provided period (if available)
        # This is used only to retrieve previous-day actual volumes.
        has_volume = 'amount' in df.columns or 'volume' in df.columns or 'vol' in df.columns
        if not has_volume:
            # If actual volume not provided in prediction input, create an empty frame with NaN values
            df['amount'] = np.nan
        else:
            # Ensure 'amount' column exists (like in fit)
            if 'amount' not in df.columns:
                vol_col_candidates = [col for col in ['volume', 'vol', 'amount'] if col in df.columns]
                df['amount'] = df[vol_col_candidates[0]]
        # Pivot by date to get actual volumes (if any) for reference
        pred_dates = df['date'].unique()
        test_vol = df.pivot(index='date', columns='interval', values='amount').reindex(pred_dates)
        # Ensure sorted by date
        test_vol = test_vol.sort_index()

        # Prepare a DataFrame to store predictions in pivot form
        pred_vol = pd.DataFrame(index=test_vol.index, columns=range(1, self.num_intervals+1), dtype=float)

        # Iterate over each day in the prediction set
        prev_day_vols = None
        for idx, current_date in enumerate(pred_vol.index):
            # Determine previous day's volumes:
            if idx == 0:
                # For the first prediction day, use last training day's actual volumes
                prev_day_vols = self.last_train_vols
            else:
                # Use the previous day from prediction set (actual if available, otherwise predicted from prior iteration)
                prev_day_actuals = test_vol.iloc[idx-1]
                if not pd.isna(prev_day_actuals).all():
                    # If actual volumes are present for previous day
                    prev_day_vols = prev_day_actuals
                else:
                    # If actuals not provided, fall back to our predicted values from previous day
                    prev_day_vols = pred_vol.iloc[idx-1]

            # Recursive intraday prediction for current_date
            # Note: We predict interval 1..N sequentially, using previous intervals' predicted values.
            for i in range(1, self.num_intervals + 1):
                # Fetch regression coefficients for interval i
                beta = self.coefs.get(i)
                if beta is None:
                    raise RuntimeError(f"No model coefficients found for interval {i}.")
                # Construct predictors based on model type
                if i == 1:
                    # X = [1, prev_day_vol_{i}] 
                    prev_day_val = prev_day_vols[i] if i in prev_day_vols.index else prev_day_vols
                    # (prev_day_vols might be a Series with index as interval numbers)
                    x_i = beta[0] + beta[1] * (prev_day_val if not np.isnan(prev_day_val) else 0.0)
                else:
                    # X = [1, vol_{i-1}(current day), prev_day_vol_{i}]
                    prev_day_val = prev_day_vols[i] if i in prev_day_vols.index else prev_day_vols
                    prev_interval_pred = pred_vol.at[current_date, i-1]
                    if np.isnan(prev_interval_pred):
                        prev_interval_pred = 0.0  # if somehow previous interval missing (should not happen after sequential fill)
                    x_i = beta[0] + beta[1] * prev_interval_pred + beta[2] * (prev_day_val if not np.isnan(prev_day_val) else 0.0)
                # Avoid negative predictions
                if x_i < 0:
                    x_i = 0.0
                pred_vol.at[current_date, i] = x_i

        # Flatten the predictions to a Series aligned with the input DataFrame order
        pred_flat = pred_vol.stack()  # multi-index (date, interval) -> value
        pred_flat.index.names = ['date', 'interval']
        # Create a Series of predictions for each row in the original input data
        # We align by merging on date and interval to preserve the original ordering
        df_sort = df[['date', 'interval']].copy()
        pred_series = pd.merge(df_sort, pred_flat.rename('predicted'), how='left', on=['date','interval'])['predicted']
        pred_series.index = data.index  # reattach original index ordering
        return pred_series

    def get_state(self):
        """
        Return the model parameters for each interval. 
        Provides regression coefficients and residual std dev for each sub-model.
        """
        if self.coefs is None or self.resid_std is None:
            return None
        model_state = {}
        for i in range(1, self.num_intervals + 1):
            coef = self.coefs.get(i)
            sigma = self.resid_std.get(i)
            if coef is None:
                continue
            # Package coefficients in a dict for clarity
            if i == 1:
                # Interval 1 has form: vol_{t,1} = intercept + phi1 * vol_{t-1,1} + err
                params = {
                    'intercept': coef[0],
                    'phi_prev_day': coef[1],
                }
            else:
                # Interval i: vol_{t,i} = intercept + beta * vol_{t,i-1} + gamma * vol_{t-1,i} + err
                params = {
                    'intercept': coef[0],
                    'beta_prev_interval': coef[1],
                    'gamma_prev_day': coef[2],
                }
            model_state[i] = {
                'coefficients': params,
                'resid_std': sigma
            }
        return model_state